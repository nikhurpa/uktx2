<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Map Toolbox: Marker / Line / Route / Direction-Route</title>
  <style>
    html, body, #map { height: 100%; margin: 0; }
    /* Toolbox */
    .toolbox {
      position: absolute; top: 12px; left: 12px; z-index: 5;
      background: #fff; border-radius: 12px; box-shadow: 0 6px 20px rgba(0,0,0,.15);
      display: flex; gap: 6px; padding: 8px;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .tool-btn {
      border: 1px solid #ddd; border-radius: 10px; padding: 8px 10px; cursor: pointer;
      font-size: 14px; user-select: none; background: #fafafa;
    }
    .tool-btn.active { background: #2563eb; color: #fff; border-color: #1d4ed8; }
    .tool-btn:hover { background: #f0f4ff; }
    /* Status / instructions */
    .status {
      position: absolute; top: 62px; left: 12px; z-index: 5;
      background: rgba(0,0,0,.75); color: #fff; padding: 8px 10px; border-radius: 8px;
      font-size: 13px; max-width: 320px;
    }
    /* Context menu */
    .context-menu {
      position: absolute; z-index: 10; background: #fff; border: 1px solid #ddd;
      border-radius: 8px; box-shadow: 0 10px 30px rgba(0,0,0,.2); padding: 6px; display: none;
      min-width: 180px; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }
    .context-item {
      padding: 8px 10px; border-radius: 6px; cursor: pointer; font-size: 14px;
    }
    .context-item:hover { background: #f3f4f6; }
    /* Totals badge for measuring */
    .totals {
      position: absolute; bottom: 16px; left: 12px; z-index: 5;
      background: #111827; color: #fff; padding: 8px 10px; border-radius: 8px; font-size: 13px;
      min-width: 140px; text-align: center;
    }
    /* Target cursor image for Route mode if you want custom pointer (optional) */
    .target-cursor { cursor: crosshair; }
  </style>

  <!-- Load Maps JS API (geometry library is needed for measuring) -->
  <script src="https://maps.googleapis.com/maps/api/js?key=AIzaSyAH06384nr0EpGqBZXDmkbGxHoWtpKjGPE&libraries=geometry"></script>
</head>
<body>
  <div class="toolbox">
    <div id="btnMarker" class="tool-btn">Marker</div>
    <div id="btnLine" class="tool-btn">Line</div>
    <div id="btnRoute" class="tool-btn">Route</div>
    <div id="btnDir" class="tool-btn">Direction-Route</div>
  </div>

  <div id="status" class="status">Select a mode to start.</div>
  <div id="map"></div>
  <div id="contextMenu" class="context-menu">
    <div id="ctxView" class="context-item">View details</div>
    <div id="ctxEdit" class="context-item">Edit details</div>
  </div>
  <div id="totals" class="totals" style="display:none;">Total: 0 m</div>

  <script>
    // === Globals ===
    let map, mode = null;
    let activeBtn = null;
    let statusEl = document.getElementById('status');
    let totalsEl = document.getElementById('totals');

    // Context menu state
    const ctxMenu = document.getElementById('contextMenu');
    let ctxTarget = null; // { type: 'marker'|'line'|'routePoint'|'measurePath', obj: ..., id: ... }

    // Marker mode data
    let markers = []; // {id, marker}
    let mid = 1;

    // Line mode data
    let lineFirstPoint = null;
    let lines = []; // {id, polyline}
    let lid = 1;

    // Route mode data
    let routeDrawing = false;
    let routePath = null;           // google.maps.Polyline
    let routePoints = new google.maps.MVCArray(); // vertices
    let routeDots = [];             // array of small red markers (with index)
    let routeSelected = false;
    const ROUTE_SAMPLE_MIN_M = 5;   // capture every 5 meters (tweak)

    // Direction / Measure mode data
    let measurePath = null;            // google.maps.Polyline
    let measurePoints = new google.maps.MVCArray();
    let measureSegments = [];          // { segLine, labelInfoWindow, distM }
    let totalDistanceM = 0;

    // Utility: select/highlight styles
    const normalLineStyle = { strokeColor: '#ef4444', strokeOpacity: 0.9, strokeWeight: 2 };
    const selectedLineStyle = { strokeColor: '#10b981', strokeOpacity: 1, strokeWeight: 4 };

    const smallRedDotIcon = {
      path: google.maps.SymbolPath.CIRCLE,
      scale: 3,
      fillColor: '#ef4444', fillOpacity: 1,
      strokeColor: '#ffffff', strokeWeight: 1
    };

    const verticalArrowIcon = {
      path: "M 0 -15 L -5 0 L -2 0 L -2 10 L 2 10 L 2 0 L 5 0 Z",
      fillColor: "red", fillOpacity: 1,
      strokeColor: "black", strokeWeight: 1,
      anchor: new google.maps.Point(0, 0)
    };

    // === Init Map ===
    function initMap() {
      map = new google.maps.Map(document.getElementById('map'), {
        center: { lat: 28.6139, lng: 77.2090 },
        zoom: 15,
        draggableCursor: 'default',
        draggingCursor: 'grabbing'
      });

      // Toolbox buttons
      bindToolButtons();

      // Map listeners — delegate by mode
      map.addListener('click', onMapClick);
      map.addListener('mousedown', onMapMouseDown);
      map.addListener('mousemove', onMapMouseMove);
      map.addListener('mouseup', onMapMouseUp);
      map.addListener('rightclick', () => hideContextMenu());

      // Dismiss context menu on global click
      document.addEventListener('click', (e) => {
        // Close if clicking outside the menu
        if (!ctxMenu.contains(e.target)) hideContextMenu();
      });

      // Context menu actions
      document.getElementById('ctxView').addEventListener('click', () => handleContext('view'));
      document.getElementById('ctxEdit').addEventListener('click', () => handleContext('edit'));

      setMode('Marker'); // default mode
    }

    // === Toolbox ===
    function bindToolButtons() {
      const bMarker = document.getElementById('btnMarker');
      const bLine = document.getElementById('btnLine');
      const bRoute = document.getElementById('btnRoute');
      const bDir = document.getElementById('btnDir');

      bMarker.onclick = () => setMode('Marker');
      bLine.onclick = () => setMode('Line');
      bRoute.onclick = () => setMode('Route');
      bDir.onclick = () => setMode('Direction');
    }

    function setMode(newMode) {
      mode = newMode;
      // UI highlight
      ['btnMarker','btnLine','btnRoute','btnDir'].forEach(id => {
        const el = document.getElementById(id);
        el.classList.toggle('active', (
          (id==='btnMarker' && mode==='Marker') ||
          (id==='btnLine' && mode==='Line') ||
          (id==='btnRoute' && mode==='Route') ||
          (id==='btnDir' && mode==='Direction')
        ));
      });

      // Cursor / instructions
      hideContextMenu();
      switch (mode) {
        case 'Marker':
          map.setOptions({ draggableCursor: 'crosshair' });
          statusEl.textContent = 'Marker mode: Click on map to add a marker. Click a marker to select; right-click for details.';
          break;
        case 'Line':
          map.setOptions({ draggableCursor: 'crosshair' });
          alert('Line mode: Select first point and then second point to draw a line.');
          lineFirstPoint = null;
          statusEl.textContent = 'Line mode: Click first point, then click second point.';
          break;
        case 'Route':
          map.setOptions({ draggableCursor: 'crosshair' });
          statusEl.textContent = 'Route mode: Mouse down and drag to draw. Red dots are draggable; right-click a dot to delete. Click path to insert a point.';
          ensureRouteObjects();
          break;
        case 'Direction':
          map.setOptions({ draggableCursor: 'crosshair' });
          statusEl.textContent = 'Direction-Route (Measure): Click to add points; shows segment and total distance. Right-click map to finish.';
          ensureMeasureObjects();
          break;
      }
    }

    // === Marker Mode ===
    function onMapClick(e) {
      if (mode === 'Marker') {
        const id = mid++;
        const m = new google.maps.Marker({
          position: e.latLng, map, draggable: false,
          icon: verticalArrowIcon
        });
        m.__id = id;
        m.addListener('click', () => selectMarker(m));
        m.addListener('rightclick', (evt) => {
          ctxTarget = { type: 'marker', obj: m, id: id };
          showContextMenu(evt.pixel.x, evt.pixel.y);
        });
        markers.push({ id, marker: m });
      }
      else if (mode === 'Line') {
        handleLineClick(e.latLng);
      }
      else if (mode === 'Direction') {
        addMeasurePoint(e.latLng);
      }
      else if (mode === 'Route') {
        // Clicking the polyline will insert a point; we handle that in polyline listener
      }
    }

    function selectMarker(m) {
      // Visual hint (bounce briefly)
      m.setAnimation(google.maps.Animation.BOUNCE);
      setTimeout(() => m.setAnimation(null), 600);
    }

    // === Line Mode (two points) ===
    function handleLineClick(latLng) {
      if (!lineFirstPoint) {
        lineFirstPoint = latLng;
        statusEl.textContent = 'Line mode: Now click the second point.';
      } else {
        const id = lid++;
        const line = new google.maps.Polyline({
          path: [lineFirstPoint, latLng],
          map,
          ...normalLineStyle
        });
        line.__id = id;

        // Select on click
        line.addListener('click', (evt) => selectLine(line));

        // Context menu on rightclick
        line.addListener('rightclick', (evt) => {
          ctxTarget = { type: 'line', obj: line, id };
          showContextMenu(evt.pixel.x, evt.pixel.y);
        });

        lines.push({ id, polyline: line });
        lineFirstPoint = null;
        statusEl.textContent = 'Line drawn. Click again to start another.';
      }
    }

    function selectLine(line) {
      lines.forEach(l => l.polyline.setOptions(normalLineStyle));
      line.setOptions(selectedLineStyle);
      // Quick distance info
      const p = line.getPath();
      if (p.getLength() === 2) {
        const d = google.maps.geometry.spherical.computeDistanceBetween(p.getAt(0), p.getAt(1));
        statusEl.textContent = `Selected line: ${formatMeters(d)}.`;
      }
    }

    // === Route Mode (mousedown drag) ===
    function ensureRouteObjects() {
      if (!routePath) {
        routePath = new google.maps.Polyline({
          path: routePoints,
          map,
          ...normalLineStyle
        });

        // Select route on click, and insert a point at clicked path
        routePath.addListener('click', (evt) => {
          selectRoute(true);
          insertRoutePointAt(evt.latLng, evt);
        });

        // Right-click anywhere on route: show path context (if you want)
        routePath.addListener('rightclick', (evt) => {
          ctxTarget = { type: 'routePath', obj: routePath, id: 'route' };
          showContextMenu(evt.pixel.x, evt.pixel.y);
        });
      }
    }

    function onMapMouseDown(e) {
      if (mode !== 'Route') return;
      routeDrawing = true;
      selectRoute(true);
      clearRoute(); // start a new route each drag; remove this line to keep appending
      addRouteVertex(e.latLng, true);
    }

    function onMapMouseMove(e) {
      if (mode !== 'Route' || !routeDrawing) return;
      const last = routePoints.getLength() ? routePoints.getAt(routePoints.getLength()-1) : null;
      if (!last) { addRouteVertex(e.latLng, true); return; }
      const dist = google.maps.geometry.spherical.computeDistanceBetween(last, e.latLng);
      if (dist >= ROUTE_SAMPLE_MIN_M) {
        addRouteVertex(e.latLng, true);
      }
    }

    function onMapMouseUp(e) {
      if (mode !== 'Route') return;
      routeDrawing = false;
    }

    function clearRoute() {
      // remove red dots
      routeDots.forEach(d => d.setMap(null));
      routeDots = [];
      // clear polyline vertices
      while (routePoints.getLength()) routePoints.removeAt(routePoints.getLength()-1);
    }

    function selectRoute(sel) {
      routeSelected = sel;
      routePath && routePath.setOptions(sel ? selectedLineStyle : normalLineStyle);
    }

    // Add a route vertex + a draggable red dot
    function addRouteVertex(latLng, tail = false, insertIndex = null) {
      let idx;
      if (insertIndex === null) {
        idx = routePoints.getLength();
        routePoints.push(latLng);
      } else {
        idx = insertIndex;
        routePoints.insertAt(idx, latLng);
        // Shift dot indices after idx
        routeDots.slice(idx).forEach(d => d.__idx++);
      }
      const dot = new google.maps.Marker({
        position: latLng, map,
        icon: smallRedDotIcon, draggable: true
      });
      dot.__idx = idx;

      // Drag to reshape
      dot.addListener('drag', (evt) => {
        const i = dot.__idx;
        routePoints.setAt(i, evt.latLng);
      });

      // Right-click to delete this vertex
      dot.addListener('rightclick', (evt) => {
        removeRouteVertex(dot.__idx);
      });

      // Click a dot to "select" route
      dot.addListener('click', () => selectRoute(true));

      routeDots.splice(idx, 0, dot);
    }

    function removeRouteVertex(index) {
      if (index < 0 || index >= routePoints.getLength()) return;
      // Remove dot
      const dot = routeDots[index];
      if (dot) dot.setMap(null);
      routeDots.splice(index, 1);
      // Remove vertex
      routePoints.removeAt(index);
      // Reindex dots after removed index
      routeDots.slice(index).forEach((d, k) => d.__idx = index + k);
    }

    // Insert a point at clicked location on polyline
    function insertRoutePointAt(latLng, clickEvt) {
      // Find nearest segment index to insert between
      const path = routePoints;
      if (path.getLength() < 2) return;
      let best = { i: -1, proj: null, dist: Infinity };

      for (let i = 0; i < path.getLength()-1; i++) {
        const a = path.getAt(i), b = path.getAt(i+1);
        const proj = closestPointOnSegment(a, b, latLng);
        const d = google.maps.geometry.spherical.computeDistanceBetween(latLng, proj);
        if (d < best.dist) best = { i, proj, dist: d };
      }
      if (best.i >= 0 && best.proj) {
        addRouteVertex(best.proj, false, best.i+1);
      }
    }

    // Compute closest point on segment AB to P (geodesic approximation using projection)
    function closestPointOnSegment(a, b, p) {
      // Use map projection to convert to planar points for small distances
      const proj = map.getProjection();
      const pa = proj.fromLatLngToPoint(a);
      const pb = proj.fromLatLngToPoint(b);
      const pp = proj.fromLatLngToPoint(p);

      const ax = pa.x, ay = pa.y, bx = pb.x, by = pb.y, px = pp.x, py = pp.y;
      const abx = bx - ax, aby = by - ay;
      const apx = px - ax, apy = py - ay;
      const ab2 = abx*abx + aby*aby;
      let t = ab2 ? ((apx*abx + apy*aby) / ab2) : 0;
      t = Math.max(0, Math.min(1, t));
      const qx = ax + t*abx, qy = ay + t*aby;
      return proj.fromPointToLatLng(new google.maps.Point(qx, qy));
    }

    // === Direction / Measurement Mode ===
    function ensureMeasureObjects() {
      if (!measurePath) {
        measurePath = new google.maps.Polyline({
          path: measurePoints, map,
          strokeColor: '#2563eb', strokeOpacity: 0.9, strokeWeight: 3
        });
        map.addListener('rightclick', () => finishMeasuring());
      }
    }

    function addMeasurePoint(latLng) {
      const n = measurePoints.getLength();
      measurePoints.push(latLng);

      // Segment from previous to this
      if (n >= 1) {
        const a = measurePoints.getAt(n-1), b = latLng;
        const dist = google.maps.geometry.spherical.computeDistanceBetween(a, b);

        // Draw thin overlay segment (optional, since polyline already updates)
        const seg = new google.maps.Polyline({
          path: [a, b], map,
          strokeColor: '#9ca3af', strokeOpacity: 0.7, strokeWeight: 2
        });

        // Label at midpoint
        const mid = google.maps.geometry.spherical.interpolate(a, b, 0.5);
        const iw = new google.maps.InfoWindow({
          content: `<div style="font-size:12px;">${formatMeters(dist)}</div>`,
          position: mid
        });
        iw.open({ map });

        measureSegments.push({ segLine: seg, labelInfoWindow: iw, distM: dist });
        totalDistanceM += dist;
        showTotal();
      }
    }

    function finishMeasuring() {
      if (!measurePath || measurePoints.getLength() === 0) return;
      // Keep the path as-is; to start a fresh measure, clear:
      // Clear overlays if you want fresh session:
      // clearMeasure();
      statusEl.textContent = 'Measurement finished. Click to start another; right-click to finish.';
    }

    function clearMeasure() {
      measureSegments.forEach(s => {
        s.segLine.setMap(null);
        s.labelInfoWindow.close();
      });
      measureSegments = [];
      while (measurePoints.getLength()) measurePoints.removeAt(measurePoints.getLength()-1);
      totalDistanceM = 0;
      showTotal();
    }

    function showTotal() {
      totalsEl.style.display = 'block';
      totalsEl.textContent = `Total: ${formatMeters(totalDistanceM)}`;
    }

    // === Context Menu ===
    function showContextMenu(px, py) {
      ctxMenu.style.left = px + 'px';
      ctxMenu.style.top = py + 'px';
      ctxMenu.style.display = 'block';
    }
    function hideContextMenu() { ctxMenu.style.display = 'none'; ctxTarget = null; }

    async function handleContext(action) {
      if (!ctxTarget) return;
      const { type, obj, id } = ctxTarget;
      hideContextMenu();

      // Example AJAX stubs — replace with your endpoints:
      // You can pass {type, id} to your server (PHP/Node) and fetch MySQL data.
      try {
        const res = await fetch(`/api/${type}/${action}?id=${encodeURIComponent(id)}`, { method: 'GET' });
        const data = await res.json().catch(()=>({ ok:false }));
        alert(`${type} ${action}: ${JSON.stringify(data || { ok:true }, null, 2)}`);
      } catch (e) {
        alert(`${type} ${action}: (demo) would call /api/${type}/${action}?id=${id}`);
      }
    }

    // === Helpers ===
    function formatMeters(m) {
      if (m < 1000) return `${m.toFixed(1)} m`;
      return `${(m/1000).toFixed(3)} km`;
    }

    // Expose init
    window.onload = initMap;
  </script>
</body>
</html>
